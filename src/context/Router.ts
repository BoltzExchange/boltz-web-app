/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    TypedContractEvent,
    TypedContractMethod,
    TypedDeferredTopicFilter,
    TypedEventLog,
    TypedListener,
} from "boltz-core/typechain/common";
import type {
    AddressLike,
    BaseContract,
    BigNumberish,
    BytesLike,
    ContractMethod,
    ContractRunner,
    FunctionFragment,
    Interface,
    Listener,
    Result,
} from "ethers";

export declare namespace Router {
    export type ClaimStruct = {
        preimage: BytesLike;
        amount: BigNumberish;
        refundAddress: AddressLike;
        timelock: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
    };

    export type ClaimStructOutput = [
        preimage: string,
        amount: bigint,
        refundAddress: string,
        timelock: bigint,
        v: bigint,
        r: string,
        s: string,
    ] & {
        preimage: string;
        amount: bigint;
        refundAddress: string;
        timelock: bigint;
        v: bigint;
        r: string;
        s: string;
    };

    export type Erc20ClaimStruct = {
        preimage: BytesLike;
        amount: BigNumberish;
        tokenAddress: AddressLike;
        refundAddress: AddressLike;
        timelock: BigNumberish;
        v: BigNumberish;
        r: BytesLike;
        s: BytesLike;
    };

    export type Erc20ClaimStructOutput = [
        preimage: string,
        amount: bigint,
        tokenAddress: string,
        refundAddress: string,
        timelock: bigint,
        v: bigint,
        r: string,
        s: string,
    ] & {
        preimage: string;
        amount: bigint;
        tokenAddress: string;
        refundAddress: string;
        timelock: bigint;
        v: bigint;
        r: string;
        s: string;
    };

    export type CallStruct = {
        target: AddressLike;
        value: BigNumberish;
        callData: BytesLike;
    };

    export type CallStructOutput = [
        target: string,
        value: bigint,
        callData: string,
    ] & { target: string; value: bigint; callData: string };
}

export declare namespace ISignatureTransfer {
    export type TokenPermissionsStruct = {
        token: AddressLike;
        amount: BigNumberish;
    };

    export type TokenPermissionsStructOutput = [
        token: string,
        amount: bigint,
    ] & {
        token: string;
        amount: bigint;
    };

    export type PermitTransferFromStruct = {
        permitted: ISignatureTransfer.TokenPermissionsStruct;
        nonce: BigNumberish;
        deadline: BigNumberish;
    };

    export type PermitTransferFromStructOutput = [
        permitted: ISignatureTransfer.TokenPermissionsStructOutput,
        nonce: bigint,
        deadline: bigint,
    ] & {
        permitted: ISignatureTransfer.TokenPermissionsStructOutput;
        nonce: bigint;
        deadline: bigint;
    };
}

export interface RouterInterface extends Interface {
    getFunction(
        nameOrSignature:
            | "DOMAIN_SEPARATOR"
            | "ERC20_SWAP_CONTRACT"
            | "PERMIT2"
            | "SWAP_CONTRACT"
            | "TYPEHASH_CLAIM"
            | "TYPEHASH_CLAIM_CALL"
            | "TYPEHASH_EXECUTE_LOCK_ERC20"
            | "TYPESTRING_EXECUTE_LOCK_ERC20"
            | "VERSION"
            | "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes)"
            | "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)"
            | "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)"
            | "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes)"
            | "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)"
            | "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)"
            | "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)"
            | "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)"
            | "executeAndLock"
            | "executeAndLockERC20"
            | "executeAndLockERC20WithPermit2",
    ): FunctionFragment;

    encodeFunctionData(
        functionFragment: "DOMAIN_SEPARATOR",
        values?: undefined,
    ): string;
    encodeFunctionData(
        functionFragment: "ERC20_SWAP_CONTRACT",
        values?: undefined,
    ): string;
    encodeFunctionData(functionFragment: "PERMIT2", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "SWAP_CONTRACT",
        values?: undefined,
    ): string;
    encodeFunctionData(
        functionFragment: "TYPEHASH_CLAIM",
        values?: undefined,
    ): string;
    encodeFunctionData(
        functionFragment: "TYPEHASH_CLAIM_CALL",
        values?: undefined,
    ): string;
    encodeFunctionData(
        functionFragment: "TYPEHASH_EXECUTE_LOCK_ERC20",
        values?: undefined,
    ): string;
    encodeFunctionData(
        functionFragment: "TYPESTRING_EXECUTE_LOCK_ERC20",
        values?: undefined,
    ): string;
    encodeFunctionData(functionFragment: "VERSION", values?: undefined): string;
    encodeFunctionData(
        functionFragment: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes)",
        values: [Router.ClaimStruct, AddressLike, BytesLike],
    ): string;
    encodeFunctionData(
        functionFragment: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
        values: [
            Router.ClaimStruct,
            AddressLike,
            BytesLike,
            BigNumberish,
            BytesLike,
            BytesLike,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
        values: [
            Router.Erc20ClaimStruct,
            AddressLike,
            BytesLike,
            BigNumberish,
            BytesLike,
            BytesLike,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes)",
        values: [Router.Erc20ClaimStruct, AddressLike, BytesLike],
    ): string;
    encodeFunctionData(
        functionFragment: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
        values: [
            Router.Erc20ClaimStruct,
            Router.CallStruct[],
            AddressLike,
            BigNumberish,
            AddressLike,
            BigNumberish,
            BytesLike,
            BytesLike,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
        values: [
            Router.Erc20ClaimStruct,
            Router.CallStruct[],
            AddressLike,
            BigNumberish,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
        values: [
            Router.ClaimStruct,
            Router.CallStruct[],
            AddressLike,
            BigNumberish,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
        values: [
            Router.ClaimStruct,
            Router.CallStruct[],
            AddressLike,
            BigNumberish,
            AddressLike,
            BigNumberish,
            BytesLike,
            BytesLike,
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "executeAndLock",
        values: [
            BytesLike,
            AddressLike,
            AddressLike,
            BigNumberish,
            Router.CallStruct[],
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "executeAndLockERC20",
        values: [
            BytesLike,
            AddressLike,
            AddressLike,
            AddressLike,
            BigNumberish,
            Router.CallStruct[],
        ],
    ): string;
    encodeFunctionData(
        functionFragment: "executeAndLockERC20WithPermit2",
        values: [
            BytesLike,
            AddressLike,
            AddressLike,
            AddressLike,
            BigNumberish,
            Router.CallStruct[],
            ISignatureTransfer.PermitTransferFromStruct,
            BytesLike,
        ],
    ): string;

    decodeFunctionResult(
        functionFragment: "DOMAIN_SEPARATOR",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "ERC20_SWAP_CONTRACT",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(functionFragment: "PERMIT2", data: BytesLike): Result;
    decodeFunctionResult(
        functionFragment: "SWAP_CONTRACT",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "TYPEHASH_CLAIM",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "TYPEHASH_CLAIM_CALL",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "TYPEHASH_EXECUTE_LOCK_ERC20",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "TYPESTRING_EXECUTE_LOCK_ERC20",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(functionFragment: "VERSION", data: BytesLike): Result;
    decodeFunctionResult(
        functionFragment: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "executeAndLock",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "executeAndLockERC20",
        data: BytesLike,
    ): Result;
    decodeFunctionResult(
        functionFragment: "executeAndLockERC20WithPermit2",
        data: BytesLike,
    ): Result;
}

export interface Router extends BaseContract {
    connect(runner?: ContractRunner | null): Router;
    waitForDeployment(): Promise<this>;

    interface: RouterInterface;

    queryFilter<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined,
    ): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined,
    ): Promise<Array<TypedEventLog<TCEvent>>>;

    on<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;
    on<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;

    once<TCEvent extends TypedContractEvent>(
        event: TCEvent,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;
    once<TCEvent extends TypedContractEvent>(
        filter: TypedDeferredTopicFilter<TCEvent>,
        listener: TypedListener<TCEvent>,
    ): Promise<this>;

    listeners<TCEvent extends TypedContractEvent>(
        event: TCEvent,
    ): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(
        event?: TCEvent,
    ): Promise<this>;

    DOMAIN_SEPARATOR: TypedContractMethod<[], [string], "view">;

    ERC20_SWAP_CONTRACT: TypedContractMethod<[], [string], "view">;

    PERMIT2: TypedContractMethod<[], [string], "view">;

    SWAP_CONTRACT: TypedContractMethod<[], [string], "view">;

    TYPEHASH_CLAIM: TypedContractMethod<[], [string], "view">;

    TYPEHASH_CLAIM_CALL: TypedContractMethod<[], [string], "view">;

    TYPEHASH_EXECUTE_LOCK_ERC20: TypedContractMethod<[], [string], "view">;

    TYPESTRING_EXECUTE_LOCK_ERC20: TypedContractMethod<[], [string], "view">;

    VERSION: TypedContractMethod<[], [bigint], "view">;

    "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes)": TypedContractMethod<
        [claim: Router.ClaimStruct, callee: AddressLike, callData: BytesLike],
        [void],
        "nonpayable"
    >;

    "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)": TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;

    "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)": TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;

    "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes)": TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
        ],
        [void],
        "nonpayable"
    >;

    "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)": TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
            destination: AddressLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;

    "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)": TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
        ],
        [void],
        "nonpayable"
    >;

    "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)": TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
        ],
        [void],
        "nonpayable"
    >;

    "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)": TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
            destination: AddressLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;

    executeAndLock: TypedContractMethod<
        [
            preimageHash: BytesLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
        ],
        [void],
        "payable"
    >;

    executeAndLockERC20: TypedContractMethod<
        [
            preimageHash: BytesLike,
            tokenAddress: AddressLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
        ],
        [void],
        "payable"
    >;

    executeAndLockERC20WithPermit2: TypedContractMethod<
        [
            preimageHash: BytesLike,
            tokenAddress: AddressLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
            permit: ISignatureTransfer.PermitTransferFromStruct,
            signature: BytesLike,
        ],
        [void],
        "payable"
    >;

    getFunction<T extends ContractMethod = ContractMethod>(
        key: string | FunctionFragment,
    ): T;

    getFunction(
        nameOrSignature: "DOMAIN_SEPARATOR",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "ERC20_SWAP_CONTRACT",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "PERMIT2",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "SWAP_CONTRACT",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "TYPEHASH_CLAIM",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "TYPEHASH_CLAIM_CALL",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "TYPEHASH_EXECUTE_LOCK_ERC20",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "TYPESTRING_EXECUTE_LOCK_ERC20",
    ): TypedContractMethod<[], [string], "view">;
    getFunction(
        nameOrSignature: "VERSION",
    ): TypedContractMethod<[], [bigint], "view">;
    getFunction(
        nameOrSignature: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes)",
    ): TypedContractMethod<
        [claim: Router.ClaimStruct, callee: AddressLike, callData: BytesLike],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimCall((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
    ): TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes,uint8,bytes32,bytes32)",
    ): TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimERC20Call((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),address,bytes)",
    ): TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            callee: AddressLike,
            callData: BytesLike,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
    ): TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
            destination: AddressLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimERC20Execute((bytes32,uint256,address,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
    ): TypedContractMethod<
        [
            claim: Router.Erc20ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256)",
    ): TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "claimExecute((bytes32,uint256,address,uint256,uint8,bytes32,bytes32),(address,uint256,bytes)[],address,uint256,address,uint8,bytes32,bytes32)",
    ): TypedContractMethod<
        [
            claim: Router.ClaimStruct,
            calls: Router.CallStruct[],
            token: AddressLike,
            minAmountOut: BigNumberish,
            destination: AddressLike,
            v: BigNumberish,
            r: BytesLike,
            s: BytesLike,
        ],
        [void],
        "nonpayable"
    >;
    getFunction(
        nameOrSignature: "executeAndLock",
    ): TypedContractMethod<
        [
            preimageHash: BytesLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
        ],
        [void],
        "payable"
    >;
    getFunction(
        nameOrSignature: "executeAndLockERC20",
    ): TypedContractMethod<
        [
            preimageHash: BytesLike,
            tokenAddress: AddressLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
        ],
        [void],
        "payable"
    >;
    getFunction(
        nameOrSignature: "executeAndLockERC20WithPermit2",
    ): TypedContractMethod<
        [
            preimageHash: BytesLike,
            tokenAddress: AddressLike,
            claimAddress: AddressLike,
            refundAddress: AddressLike,
            timelock: BigNumberish,
            calls: Router.CallStruct[],
            permit: ISignatureTransfer.PermitTransferFromStruct,
            signature: BytesLike,
        ],
        [void],
        "payable"
    >;

    filters: {};
}
